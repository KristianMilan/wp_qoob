---
title: Developers Guide
active_menu: Developers Guide
main_menu: dev
---

<h1>Basics</h1>
<p>Smart framework consists of smart modules. Each module is designed to be able to use it from any part of wordpress:</p>
<ul>
<li>Wordpress plugin</li>
<li>Part of theme</li>
<li>Submodule in other modules</li>
</ul>
<p>Because of this modular system you can easy customize SmartBuilder for your use. Add or remove modules without breaking core. Even use two or more the same modules without conflicts.</p>
<h2>Module directory structure</h2>
<pre><code>index.php - Entry point. To add your module you need include this file
includes\ - modulename.class.php located here and other php files
assets\ - Directory for assets
assets\img\ - Directory for images
assets\js\ - Directory for JavaScript files
assets\css\ - Directory for Styles
templates\ - Directory with templates
modules\ - Submodules for this module
</code></pre>
<h2>Modules directory</h2>
<p>
Any module can has nested submodules. These submodules can have their submodules. And so on. By default submodules located in &quot;modules&quot; dir of module.</p>
<h2>Module class</h2>
<p>
Each module has module class. Module class should be inherit from &quot;SmartModule&quot; class. Class name is also module name.</p>
<h2>Includes directory</h2>
<p>
All files from this directory will be included automatic. File with module class should be here.</p>
<h2>Assets directory</h2>
<p>
Images, JavaScript files, CSS files and other public files located in this folder.</p>
<h2>Templates directory</h2>
<p>
Smart framework follows the rule: <em>No HTML/CSS/JS code in PHP classes</em>.
Static HTML/JS/CSS located in assets folder. Dynamic HTML/JS/CSS located in templates folder. What does it means &quot;dynamic&quot;? It means that HTML/JS/CSS code will be created from php template.</p>
<h2>Modules initialization</h2>
<h3>Loading modules</h3>
<p>Each module inherit <code>SmartModule</code> class. <code>SmartModule</code> class located in root module. We call this module <code>Smart</code>. Obviously, all our modules will be loaded after <code>Smart</code> module. If we try to load some module before module <code>Smart</code> has been loaded we should return and load this module later. We use action <code>Smart_load_module</code> for do this &quot;lazy&quot; loading.</p>
<p>If module <code>Smart</code> loaded we do next steps:</p>
<ol>
<li>Load all submodules from &quot;modules&quot; directory</li>
<li>Include all files from include dir and register module class. This occurs only if module class has not been initialized before.</li>
</ol>
<h3>Registration module</h3>
<p>All modules registering in specific order. We need register <code>SmartComponentText</code> module after <code>SmartComponent</code> module. <code>SmartShortCodes</code> should be registered after <code>Smart</code> module. This is accomplished due to the dependency system. How it work?
<code>index.php</code> is file who responsible for this. Let`s see:</p>
<pre><code class="php">if (defined(&#39;ABSPATH&#39;)) {

    $module = &quot;SmartComponentTest&quot;; //Module Name the same as class name
    $dependency = &quot;SmartComponent&quot;; //Load after module SmartComponent will be loaded

    ...
</code></pre>
<p>Once module registered it call:</p>
<pre><code class="php">do_action(MODULE_NAME.&quot;_loaded&quot;);
</code></pre>
<h3>Conclusion</h3>
<p>As you see smart modules is very flexible to use. For example you can:</p>
<ol>
<li>Have different plugins. This plugins have the same submodule. Only one of this modules will be registered, but all their submodules will be loaded.</li>
<li>Have module in theme. And other module in plugins dir. They all will be loaded and registered the same way, no matter where module located.</li>
</ol>
<h2>Modules list</h2>
<p>Access to registered module list:</p>
<pre><code class="php">global $smart;
$smart-&gt;modules();            // return all modules
$smart-&gt;modules(&#39;component&#39;); // return all modules with type &#39;component&#39;
$smart-&gt;modules(&#39;animation&#39;); // return all modules with type &#39;animation&#39;
</code></pre>
<h2>Method register()</h2>
<p>
All modules should has <code>register</code> method. This method is describe all actions, filters and shortcodes. Yes you do not need search method do_action in other files all what you need is here in method register.
Example:</p>
<pre><code class="php">...
public function register() {

    //Register mce plugin
    add_filter(&#39;mce_external_plugins&#39;, array($this, &#39;register_mce_plugin&#39;));

    //Add button to mce toolbar
    add_filter(&#39;mce_buttons&#39;, array($this, &#39;register_mce_button&#39;));

    //Load JS and CSS for frontend
    add_action(&#39;wp_enqueue_scripts&#39;, array($this, &#39;wp_enqueue_scripts&#39;));

    //Load JS and CSS for backend
    add_action(&#39;admin_enqueue_scripts&#39;, array($this, &#39;admin_enqueue_scripts&#39;));

    //Ajax on load settings window
    add_action(&#39;wp_ajax_sc_window_components_list&#39;, array($this, &#39;wp_ajax_sc_window_components_list&#39;));

    //Do default actions
    parent::register();
}
...
</code></pre>
<p>Best practice. All handlers should be a method of your module class. Say &#39;no&#39; functions without class.</p>
<h2>Method type()</h2>
<p>
Each smart module has a type. It can be &#39;core&#39; module or &#39;component&#39;. To know what type of module you can call <code>type</code> method</p>
<p>Reserved types:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>String</th>
<th>Desctiption</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smart::CORE_TYPE</td>
<td>core</td>
<td>core module</td>
</tr>
<tr>
<td>AbstractComponent::COMPONENT_TYPE</td>
<td>component</td>
<td>builder component module</td>
</tr>
<tr>
<td>Animation::ANIMATION_TYPE</td>
<td>animation</td>
<td>animation module</td>
</tr>
<tr>
<td>IconSet::ICONSET_TYPE</td>
<td>iconset</td>
<td>iconset module</td>
</tr>
<tr>
<td>Font::Font_TYPE</td>
<td>font</td>
<td>font module</td>
</tr>
</tbody>
</table>
<h2>Dependencies</h2>
<p>
All smart modules loaded in specific order. We need load <code>Text</code> module after <code>SmartShortCodes</code> module. <code>SmartShortCodes</code> should be loaded after <code>Smart</code> module. This is accomplished due to the dependency system. How it work?
<code>index.php</code> is file who responsible for this. Let`s see:</p>
<pre><code class="php">if (defined(&#39;ABSPATH&#39;)) {

    $module = &quot;Test&quot;; //Module Name
    $dependency = &quot;SmartShortCodes&quot;; //Load after module Smart will be loaded

    ...
</code></pre>
<p>Once module registered it call:</p>
<pre><code class="php">do_action(MODULE_NAME.&quot;_loaded&quot;);
</code></pre>
<h2>Default register actions</h2>
<p>
From module to module your register method will repeat a lot of default actions</p>
<ul>
<li>Scan module dir for submodules</li>
<li>Add class to smartmodules list</li>
<li>Call do_action(Module.&#39;_loaded&#39;)</li>
</ul>
<p>Fortunately method <code>SmartModule::register($file)</code> already did all default actions
So you just need to add next line in your <code>register()</code> method</p>
<pre><code class="php">public function register() {

    //Actions and filters

    //Do default actions
    parent::register();
}
</code></pre>
<h2>Register css and JavaScript files</h2>
<p>As you know for adding css and js files in your wordpress project you need use actions <code>wp_enqueue_scripts</code> and <code>admin_enqueue_scripts</code> for frontend and backend respectively. So in your <code>register</code> method add next</p>
<pre><code class="php">//Load JS and CSS for frontend
add_action(&#39;wp_enqueue_scripts&#39;, array($this, &#39;wp_enqueue_scripts&#39;));

//Load JS and CSS for backend
add_action(&#39;admin_enqueue_scripts&#39;, array($this, &#39;admin_enqueue_scripts&#39;));
</code></pre>
<p>And create methods <code>wp_enqueue_scripts</code> and <code>admin_enqueue_scripts</code> with calling methods <code>wp_enqueue_script</code> or <code>wp_localize_script</code> in module class. 
Example:</p>
<pre><code class="php">    static public function admin_enqueue_scripts() {
        //Load sc.window.js
        wp_enqueue_script(&#39;shortcodes.window&#39;, $this-&gt;getUrlAssets().&quot;/js/sc.window.js&quot;, array(&#39;jquery-ui-widget&#39;));

        wp_localize_script(&#39;shortcodes.window&#39;, &#39;objectL10n_shortcodes&#39;, $this-&gt;localize_vars());
        //Load sc.window.css
        wp_enqueue_style(&#39;shortcodes.window&#39;, $this-&gt;getUrlAssets().&quot;css/sc.window.css&quot;);

    }
</code></pre>
<h2>How to name css and JavaScript files</h2>
<h2>Core Modules</h2>
<h3>core</h3>
<p>
core module is start module for other modules. It contains basic classes used in other modules.</p>
<h3>sc</h3>
<h3>builder</h3>
<h1>Create new module</h1>
<h1>API</h1>
